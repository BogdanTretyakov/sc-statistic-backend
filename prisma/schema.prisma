generator client {
  provider = "prisma-client-js"
}

generator kysely {
  provider = "prisma-kysely"
  output   = "./../src/common/types"
  fileName = "kysely.ts"
}

generator json {
  provider  = "prisma-json-types-generator"
  namespace = "PrismaJson"
  allowAny  = false
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model MapVersion {
  id         Int     @id @default(autoincrement())
  mapName    String  @unique
  mapType    String? @db.VarChar(2)
  mapVersion String? @db.VarChar(6)
  mapPatch   String? @db.VarChar(4)
  dataKey    String?
  ignore     Boolean @default(false)

  MapProcess MapProcess[]
  Match      Match[]
}

enum MatchPlatform {
  W3Champions
}

enum ProcessError {
  BAD_MAP
  NO_MAPPING
  PARSING_ERROR
}

model MapProcess {
  id            BigInt        @id @default(autoincrement())
  mapId         Int?
  platform      MatchPlatform
  filePath      String        @unique
  mappingError  ProcessError?
  downloadError Int?          @db.SmallInt
  processed     Boolean       @default(false)

  map              MapVersion?        @relation(fields: [mapId], references: [id])
  W3ChampionsMatch W3ChampionsMatch[]
  Match            Match[]
}

model W3ChampionsMatch {
  id           String   @id @db.VarChar(24)
  time         DateTime
  season       String   @db.VarChar(4)
  /// [W3ChampionsMatchPlayer[]]
  players      Json     @db.Json
  mapProcessId BigInt?

  processId MapProcess? @relation(fields: [mapProcessId], references: [id])
}

model Match {
  id           BigInt   @id @default(autoincrement())
  duration     Int
  endAt        DateTime
  avgMmr       Int?
  avgQuantile  Int?     @db.SmallInt
  hasLeavers   Boolean
  mapId        Int
  mapProcessId BigInt

  map        MapVersion @relation(fields: [mapId], references: [id])
  mapProcess MapProcess @relation(fields: [mapProcessId], references: [id])
  players    Player[]

  @@index([endAt], name: "idx_end_at")
  @@index([mapId], name: "idx_map")
  @@index([avgQuantile, duration, hasLeavers, mapId], name: "idx_quantile_leavers_map_duration")
}

model Player {
  id               BigInt  @id @default(autoincrement())
  matchId          BigInt
  platformPlayerId Int
  place            Int     @db.SmallInt
  /// Milliseconds from match start
  timeAlive        Int
  raceId           String  @db.VarChar(4)
  bonusId          String? @db.VarChar(4)
  auraId           String? @db.VarChar(4)
  ultimateId       String? @db.VarChar(4)
  mmr              Int?
  quantile         Int?    @db.SmallInt

  platformPlayer PlatformPlayer @relation(fields: [platformPlayerId], references: [id])
  match          Match          @relation(fields: [matchId], references: [id])
  events         PlayerEvent[]

  @@unique([matchId, place])
  @@index([matchId, mmr], name: "idx_matchId_mmr")
  @@index([matchId, raceId, bonusId], name: "idx_match_race_bonus")
}

model PlatformPlayer {
  id         Int           @id @default(autoincrement())
  name       String
  platform   MatchPlatform
  lastMmr    Int?
  lastSeenAt DateTime

  Player Player[]

  @@unique([name, platform], name: "namePlatform")
}

enum PlayerEvents {
  INITIAL_RACE
  BAN_RACE
  REPICK_RACE
  HERO_BUY
  BASE_UPGRADE
  TOWER_UPGRADE
  UP_FORT2
  UP_FORT3
  UP_BARRACK2
  UP_BARRACK3
  UP_BARRACK4
  USE_ULTIMATE
}

model PlayerEvent {
  playerMatchId BigInt
  eventType     PlayerEvents
  eventId       String       @db.VarChar(4)
  /// Milliseconds from match start
  time          Int

  player Player @relation(fields: [playerMatchId], references: [id])

  @@id([playerMatchId, eventType, eventId, time])
  @@index([eventType, eventId, playerMatchId], name: "idx_event_type_id_player")
}

model DatabaseDump {
  id   String   @id @default(uuid()) @db.Uuid
  date DateTime
}

model MigrationCustom {
  name       String    @id
  finishedAt DateTime?
  error      Boolean?
}
