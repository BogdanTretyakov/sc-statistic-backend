generator client {
  provider = "prisma-client-js"
}

generator kysely {
  provider = "prisma-kysely"
  output   = "./../src/common/types"
  fileName = "kysely.ts"
}

generator json {
  provider  = "prisma-json-types-generator"
  allowAny  = "false"
  namespace = "PrismaJson"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model MapVersion {
  id         Int          @id @default(autoincrement())
  mapName    String       @unique
  mapType    String?      @db.VarChar(2)
  mapVersion String?      @db.VarChar(6)
  mapPatch   String?      @db.VarChar(4)
  dataKey    String?
  ignore     Boolean      @default(false)
  MapProcess MapProcess[]
  Match      Match[]
}

model MapProcess {
  id               BigInt             @id @default(autoincrement())
  mapId            Int?
  platform         MatchPlatform
  filePath         String             @unique
  mappingError     ProcessError?
  downloadError    Int?               @db.SmallInt
  processed        Boolean            @default(false)
  map              MapVersion?        @relation(fields: [mapId], references: [id])
  Match            Match[]
  W3ChampionsMatch W3ChampionsMatch[]
}

model W3ChampionsMatch {
  id           String      @id @db.VarChar(24)
  time         DateTime
  season       String      @db.VarChar(4)
  /// [W3ChampionsMatchPlayer[]]
  players      Json        @db.Json
  mapProcessId BigInt?
  processId    MapProcess? @relation(fields: [mapProcessId], references: [id])
}

model Match {
  id           BigInt     @id @default(autoincrement())
  duration     Int
  endAt        DateTime
  avgMmr       Int?
  avgQuantile  Int?       @db.SmallInt
  hasLeavers   Boolean
  mapId        Int
  mapProcessId BigInt
  map          MapVersion @relation(fields: [mapId], references: [id])
  mapProcess   MapProcess @relation(fields: [mapProcessId], references: [id])
  players      Player[]

  @@index([endAt], map: "idx_end_at")
  @@index([mapId], map: "idx_map")
  @@index([avgQuantile, duration, hasLeavers, mapId], map: "idx_quantile_leavers_map_duration")
}

model Player {
  id               BigInt         @id @default(autoincrement())
  matchId          BigInt
  platformPlayerId Int
  place            Int            @db.SmallInt
  /// Milliseconds from match start
  timeAlive        Int
  raceId           String         @db.VarChar(4)
  mmr              Int?
  quantile         Int?           @db.SmallInt
  match            Match          @relation(fields: [matchId], references: [id])
  platformPlayer   PlatformPlayer @relation(fields: [platformPlayerId], references: [id])
  playerDatas      PlayerData[]
  events           PlayerEvent[]

  @@unique([matchId, place])
  @@index([matchId, mmr], map: "idx_matchId_mmr")
  @@index([matchId, raceId], map: "idx_match_race")
}

model PlayerData {
  playerId BigInt
  type     PlayerDataType
  value    String         @db.VarChar(4)
  player   Player         @relation(fields: [playerId], references: [id])

  @@id([playerId, type, value])
}

model PlatformPlayer {
  id         Int           @id @default(autoincrement())
  name       String
  platform   MatchPlatform
  lastMmr    Int?
  lastSeenAt DateTime
  Player     Player[]

  @@unique([name, platform], name: "namePlatform")
}

model PlayerEvent {
  playerMatchId BigInt
  eventType     PlayerEvents
  eventId       String       @db.VarChar(4)
  /// Milliseconds from match start
  time          Int
  player        Player       @relation(fields: [playerMatchId], references: [id])

  @@id([playerMatchId, eventType, eventId, time])
  @@index([eventType, eventId, playerMatchId], map: "idx_event_type_id_player")
}

model DatabaseDump {
  id   String   @id @default(uuid()) @db.Uuid
  date DateTime
}

model MigrationCustom {
  name       String    @id
  finishedAt DateTime?
  error      Boolean?
}

model WikiData {
  dataKey String
  key     String
  data    Json   @db.Json
  sha     String

  @@id([dataKey, key])
}

enum MatchPlatform {
  W3Champions
}

enum ProcessError {
  BAD_MAP
  NO_MAPPING
  PARSING_ERROR
}

enum PlayerDataType {
  BONUS
  AURA
  ULTIMATE
}

enum PlayerEvents {
  INITIAL_RACE
  BAN_RACE
  REPICK_RACE
  HERO_BUY
  BASE_UPGRADE
  TOWER_UPGRADE
  UP_FORT2
  UP_FORT3
  UP_BARRACK2
  UP_BARRACK3
  UP_BARRACK4
  USE_ULTIMATE
}
